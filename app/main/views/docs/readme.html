<:Body>

<div class="markdown-body" style="padding:10px 40px;">

      <div class="readme-content">
        <p><a href="http://badge.fury.io/rb/volt"><img src="https://badge.fury.io/rb/volt.png" alt="Gem Version" style="max-width:100%;"></a>
<a href="https://codeclimate.com/github/voltrb/volt"><img src="https://codeclimate.com/github/voltrb/volt.png" alt="Code Climate" style="max-width:100%;"></a>
<a href="https://travis-ci.org/voltrb/volt"><img src="https://travis-ci.org/voltrb/volt.png?branch=master" alt="Build Status" style="max-width:100%;"></a>
<a href="http://inch-ci.org/github/voltrb/volt"><img src="http://inch-ci.org/github/voltrb/volt.svg?branch=master" alt="Inline docs" style="max-width:100%;"></a>
<a href="https://gitter.im/voltrb/volt"><img src="https://badges.gitter.im/voltrb/volt.png" alt="Volt Chat" style="max-width:100%;"></a></p>

<p>** For the current status of volt, read: <a href="http://voltframework.com/blog">http://voltframework.com/blog</a></p>

<h1>
<a id="volt" class="anchor" href="#volt" aria-hidden="true"><span class="octicon octicon-link"></span></a>Volt</h1>

<p>Volt is a Ruby web framework where your ruby code runs on both the server and the client (via <a href="https://github.com/opal/opal">opal</a>).  The DOM automatically updates as the user interacts with the page. Page state can be stored in the URL. If the user hits a URL directly, the HTML will first be rendered on the server for faster load times and easier indexing by search engines.</p>

<p>Instead of syncing data between the client and server via HTTP, Volt uses a persistent connection between the client and server. When data is updated on one client, it is updated in the database and any other listening clients (with almost no setup code needed).</p>

<p>Pages HTML is written in a handlebars-like template language.  Volt uses data flow/reactive programming to automatically and intelligently propagate changes to the DOM (or any other code wanting to know when a value updates).  When something in the DOM changes, Volt intelligently updates only the nodes that need to be changed.</p>

<p>See some demo videos here:
** Note: These videos are outdated, new videos coming tomorrow.</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=6ZIvs0oKnYs">Volt Todos Example</a></li>
<li><a href="https://www.youtube.com/watch?v=c478sMlhx1o">Build a Blog with Volt</a></li>
<li><a href="https://www.youtube.com/watch?v=yZIQ-2irY-Q">Reactive Values in Volt</a></li>
</ul>

<p>Check out demo apps:</p>

<ul>
<li><a href="https://github.com/voltrb/todos3">https://github.com/voltrb/todos3</a></li>
<li><a href="https://github.com/voltrb/contactsdemo">https://github.com/voltrb/contactsdemo</a></li>
</ul>

<h2>
<a id="goals" class="anchor" href="#goals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Goals</h2>

<p>Volt has the following goals:</p>

<ol>
<li>Developer happiness</li>
<li>Write once on the client and server</li>
<li>Automatic data syncing between client and server</li>
<li>Apps are built as nested components.  Components can be shared (via gems)</li>
<li>Concurrent.  Volt provides tools to simplify concurrency.  Component rendering is done in parallel on the server</li>
<li>Intelligent asset management</li>
<li>Secure (shouldn't need to be said, but it does)</li>
<li>Be fast/light</li>
<li>Understandable code base</li>
<li>Control upgradeability</li>
</ol>

<h1>
<a id="road-map" class="anchor" href="#road-map" aria-hidden="true"><span class="octicon octicon-link"></span></a>Road Map</h1>

<p>Many of the core Volt features are implemented.  We still have a bit to go before 1.0, most of it involving models.</p>

<ol>
<li>Model read/write permissions</li>
<li>User accounts, user collection, signup/login templates</li>
</ol>

<h1>
<a id="volt-guide" class="anchor" href="#volt-guide" aria-hidden="true"><span class="octicon octicon-link"></span></a>VOLT guide</h1>

<p>This guide will take you through creating a basic web application in Volt.  This tutorial assumes a basic knowledge of Ruby and web development.</p>

<p>To get started, install Volt:</p>

<pre><code>gem install volt
</code></pre>

<p>Then create a new project:</p>

<pre><code>volt new project_name
</code></pre>

<p>This will setup a basic project.  Now let's run the server:</p>

<pre><code>bundle exec volt server
</code></pre>

<p>You can access the Volt console with:</p>

<pre><code>bundle exec volt console
</code></pre>

<h1>
<a id="guide-sections" class="anchor" href="#guide-sections" aria-hidden="true"><span class="octicon octicon-link"></span></a>Guide Sections</h1>

<ol>
<li><a href="#getting-help">Getting Help</a></li>
<li>
<a href="#rendering">Rendering</a>

<ol>
<li><a href="#state-and-computations">States and Computations</a></li>
<li><a href="#computations">Computations</a></li>
</ol>
</li>
<li>
<a href="#views">Views</a>

<ol>
<li>
<a href="#bindings">Bindings</a>

<ol>
<li><a href="#content-binding">Content Binding</a></li>
<li><a href="#if-binding">If Binding</a></li>
<li><a href="#each-binding">Each Binding</a></li>
<li><a href="#attribute-bindings">Attribute Bindings</a></li>
<li><a href="#escaping">Escaping</a></li>
</ol>
</li>
</ol>
</li>
<li>
<a href="#models">Models</a>

<ol>
<li><a href="#provided-collections">Provided Collections</a></li>
<li><a href="#arraymodel-events">ArrayModel Events</a></li>
<li><a href="#automatic-model-conversion">Automatic Model Conversion</a></li>
</ol>
</li>
<li><a href="#controllers">Controllers</a></li>
<li><a href="#tasks">Tasks</a></li>
<li>
<a href="#components">Components</a>

<ol>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#assets">Assets</a></li>
<li><a href="#component-generator">Component Generator</a></li>
<li>
<a href="#provided-components">Provided Components</a>

<ol>
<li><a href="#notices">Notices</a></li>
<li><a href="#flash">Flash</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#controls">Controls</a></li>
<li>
<a href="#routes">Routes</a>

<ol>
<li><a href="#routes-file">Routes file</a></li>
</ol>
</li>
<li><a href="#testing">Testing</a></li>
<li>
<a href="#volt-helpers">Volt Helpers</a>

<ol>
<li><a href="#logging">Logging</a></li>
</ol>
</li>
</ol>

<h1>
<a id="getting-help" class="anchor" href="#getting-help" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting Help</h1>

<p>Volt is still a work in progress, but early feedback is appreciated.  Use the following to communicate with the developers, someone will get back to you very quickly:</p>

<ul>
<li>
<strong>If you need help</strong>: post on <a href="http://www.stackoverflow.com">stackoverflow.com</a>. Be sure to tag your question with <code>voltrb</code>.</li>
<li>
<strong>If you found a bug</strong>: post on <a href="https://github.com/voltrb/volt/issues">github issues</a>
</li>
<li>
<strong>If you have an idea or need a feature</strong>: post on <a href="https://github.com/voltrb/volt/issues">github issues</a>
</li>
<li>
<strong>If you want to discuss Volt</strong>: <a href="https://gitter.im/voltrb/volt">chat on gitter</a>, someone from the volt team is usually online and happy to help with anything.</li>
</ul>

<h1>
<a id="rendering" class="anchor" href="#rendering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rendering</h1>

<p>When a user interacts with a web page, typically we want to do two things:</p>

<ol>
<li>Change application state</li>
<li>Update the DOM</li>
</ol>

<p>For example when a user clicks to add a new todo item to a todo list, we might create an object to represent the todo item, then add an item to the list's DOM.  A lot of work needs to be done to make sure that the object and the DOM always stay in sync.</p>

<p>The idea of "reactive programming" can be used to simplify maintaining the DOM.  Instead of having event handlers that manage a model and manage the DOM, we have event handlers that manage reactive data models.  We describe our DOM layer in a declarative way so that it automatically knows how to render our data models.</p>

<h2>
<a id="state-and-computations" class="anchor" href="#state-and-computations" aria-hidden="true"><span class="octicon octicon-link"></span></a>State and Computations</h2>

<p>Web applications center around maintaining state.  Many events can trigger changes to a state.  Page interaction like entering text into form elements, clicking a button, links, scrolling, etc.. can all change the state of the app.  In the past, each page interaction event would manually change any state stored on a page.</p>

<p>To simplify managing application state, all application state is kept in models that can optionally be persisted in different locations.  By centralizing the application state, we reduce the amount of complex code needed to update a page.  We can then build our page's html declaratively.  The relationship to the page's models' are bound using function and method calls.</p>

<p>We want our DOM to automatically update when our model data changes.  To make this happen, Volt lets you "watch" any method/proc call and have it get called again when data accessed by the method/proc call changes.</p>

<h3>
<a id="computations" class="anchor" href="#computations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Computations</h3>

<p>Lets take a look at this in practice.  We'll use the <code>page</code> collection as an example.  (You'll see more on collections later)</p>

<p>First, we setup a computation watch.  Computations are built by calling .watch! on a Proc.  Here we'll use the ruby 1.9 proc shorthand syntax <code>-&gt; {"&#123;"} ... {38.chr + "#125;"}</code> It will run once, then run again each time the data in page._name changes.</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">page</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'Ryan'</span>
    <span class="o">-&gt;</span> <span class="p">{"&#123;"}</span> <span class="nb">puts</span> <span class="n">page</span><span class="o">.</span><span class="n">_name</span> <span class="p">{38.chr + "#125;"}</span><span class="o">.</span><span class="n">watch!</span>
    <span class="c1"># =&gt; Ryan</span>
    <span class="n">page</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'Jimmy'</span>
    <span class="c1"># =&gt; Jimmy</span>
</pre></div>

<p>Each time page._name is assigned to a new value, the computation is run again.  A re-run of the computation will be triggered when any data accessed in the previous run is changed.  This lets us access data through methods and still have watches re-triggered.</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">page</span><span class="o">.</span><span class="n">_first</span> <span class="o">=</span> <span class="s1">'Ryan'</span>
    <span class="n">page</span><span class="o">.</span><span class="n">_last</span> <span class="o">=</span> <span class="s1">'Stout'</span>

    <span class="k">def</span> <span class="nf">lookup_name</span>
      <span class="k">return</span> <span class="s2">"</span><span class="si">#{"&#123;"}</span><span class="n">page</span><span class="o">.</span><span class="n">_first</span><span class="si">{38.chr + "#125;"}</span><span class="s2"> </span><span class="si">#{"&#123;"}</span><span class="n">page</span><span class="o">.</span><span class="n">_last</span><span class="si">{38.chr + "#125;"}</span><span class="s2">"</span>
    <span class="k">end</span>

    <span class="o">-&gt;</span> <span class="k">do</span>
      <span class="nb">puts</span> <span class="n">lookup_name</span>
    <span class="k">end</span><span class="o">.</span><span class="n">watch!</span>
    <span class="c1"># =&gt; Ryan Stout</span>

    <span class="n">page</span><span class="o">.</span><span class="n">_first</span> <span class="o">=</span> <span class="s1">'Jimmy'</span>
    <span class="c1"># =&gt; Jimmy Stout</span>

    <span class="n">page</span><span class="o">.</span><span class="n">_last</span> <span class="o">=</span> <span class="s1">'Jones'</span>
    <span class="c1"># =&gt; Jimmy Jones</span>
</pre></div>

<p>When you call .watch! the return value is a Computation object.  In the event you no longer want to receive updates, you can call .stop on the computation.</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">page</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'Ryan'</span>

    <span class="n">comp</span> <span class="o">=</span> <span class="o">-&gt;</span> <span class="p">{"&#123;"}</span> <span class="nb">puts</span> <span class="n">page</span><span class="o">.</span><span class="n">_name</span> <span class="p">{38.chr + "#125;"}</span><span class="o">.</span><span class="n">watch!</span>
    <span class="c1"># =&gt; Ryan</span>

    <span class="n">page</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'Jimmy'</span>
    <span class="c1"># =&gt; Jimmy</span>

    <span class="n">comp</span><span class="o">.</span><span class="n">stop</span>

    <span class="n">page</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'Jo'</span>
    <span class="c1"># (nothing)</span>
</pre></div>

<h2>
<a id="dependencies" class="anchor" href="#dependencies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dependencies</h2>

<p>TODO: Explain Dependencies</p>

<p>As a Volt user, you rarely need to use Comptuations and Dependencies directly.  Instead you usually just interact with models and bindings.  Computations are used under the hood, and having a full understanding of what's going on is useful, but not required.</p>

<h1>
<a id="views" class="anchor" href="#views" aria-hidden="true"><span class="octicon octicon-link"></span></a>Views</h1>

<p>Views in Volt use a templating language similar to handlebars. They can be broken up into sections. A section header looks like the following:</p>

<div class="highlight highlight-html"><pre><span class="nt">&lt;:Body&gt;</span>
</pre></div>

<p>Section headers should start with a capital letter so as not to be confused with <a href="#controls">controls</a>.  Section headers do not use closing tags.  If section headers are not provided, the Body section is assumed.</p>

<p>Sections help you split up different parts of the same content (title and body usually), but within the same file.</p>

<h2>
<a id="bindings" class="anchor" href="#bindings" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bindings</h2>

<p>Once you understand the basics of ReactiveValues, we can discuss bindings. In Volt, you code your views in a handlebars like template language.  Volt provides several bindings, which handle rendering of something for you. Content bindings are anything inbetween {"&#123;"} and {38.chr + "#125;"}.</p>

<h3>
<a id="content-binding" class="anchor" href="#content-binding" aria-hidden="true"><span class="octicon octicon-link"></span></a>Content binding</h3>

<p>The most basic binding is a content binding:</p>

<div class="highlight highlight-html"><pre>    <span class="nt">&lt;p&gt;</span>{"&#123;"}some_method{38.chr + "#125;"}<span class="nt">&lt;p&gt;</span>
</pre></div>

<p>The content binding runs the Ruby code between {"&#123;"} and {38.chr + "#125;"}, then renders the return value.  If the returned value is a ReactiveValue, it will update the value updated whenever a 'changed' event is triggered on the reactive value.</p>

<h3>
<a id="if-binding" class="anchor" href="#if-binding" aria-hidden="true"><span class="octicon octicon-link"></span></a>If binding</h3>

<p>An if binding lets you provide basic flow control.</p>

<div class="highlight highlight-html"><pre>    {"&#123;"}#if _some_check?{38.chr + "#125;"}
      <span class="nt">&lt;p&gt;</span>render this<span class="nt">&lt;/p&gt;</span>
    {"&#123;"}/{38.chr + "#125;"}
</pre></div>

<p>Blocks are closed with a {"&#123;"}/{38.chr + "#125;"}</p>

<p>When the if binding is rendered, it will run the ruby code after #if.  If the code is true it will render the code below.  Again, if the returned value is reactive, it will update as that value changes.</p>

<p>If bindings can also have #elsif and #else blocks.</p>

<div class="highlight highlight-html"><pre>    {"&#123;"}#if _condition_1?{38.chr + "#125;"}
      <span class="nt">&lt;p&gt;</span>condition 1 true<span class="nt">&lt;/p&gt;</span>
    {"&#123;"}#elsif _condition_2?{38.chr + "#125;"}
      <span class="nt">&lt;p&gt;</span>condition 2 true<span class="nt">&lt;/p&gt;</span>
    {"&#123;"}#else{38.chr + "#125;"}
      <span class="nt">&lt;p&gt;</span>neither true<span class="nt">&lt;/p&gt;</span>
    {"&#123;"}/{38.chr + "#125;"}
</pre></div>

<h3>
<a id="each-binding" class="anchor" href="#each-binding" aria-hidden="true"><span class="octicon octicon-link"></span></a>Each binding</h3>

<p>For iteration over objects, the each binding is provided.</p>

<div class="highlight highlight-html"><pre>    {"&#123;"}#each _items as item{38.chr + "#125;"}
      <span class="nt">&lt;p&gt;</span>{"&#123;"}item{38.chr + "#125;"}<span class="nt">&lt;/p&gt;</span>
    {"&#123;"}/{38.chr + "#125;"}
</pre></div>

<p>Above, if _items were an array, the block would be rendered for each item, setting 'item' to the value of the array element.</p>

<p>You can also access the position of the item in the array with the #index method.</p>

<div class="highlight highlight-html"><pre>    {"&#123;"}#each _items as item{38.chr + "#125;"}
      <span class="nt">&lt;p&gt;</span>{"&#123;"}index{38.chr + "#125;"}. {"&#123;"}item{38.chr + "#125;"}<span class="nt">&lt;/p&gt;</span>
    {"&#123;"}/{38.chr + "#125;"}
</pre></div>

<p>For the array: ['one', 'two', 'three'] this would print:</p>

<pre><code>0. one
1. two
2. three
</code></pre>

<p>You can do {"&#123;"}index + 1{38.chr + "#125;"} to correct the zero offset.</p>

<p>When items are removed or added to the array, the #each binding automatically and intelligently adds or removes the items from/to the DOM.</p>

<h2>
<a id="attribute-bindings" class="anchor" href="#attribute-bindings" aria-hidden="true"><span class="octicon octicon-link"></span></a>Attribute Bindings</h2>

<p>Bindings can also be placed inside of attributes.</p>

<div class="highlight highlight-html"><pre>    <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">"{"&#123;"}#if _is_cool?{38.chr + "#125;"}cool{"&#123;"}/{38.chr + "#125;"}"</span><span class="nt">&gt;</span>Text<span class="nt">&lt;/p&gt;</span>
</pre></div>

<p>There are some special features provided to make elements work as "two way bindings":</p>

<div class="highlight highlight-html"><pre>    <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">value=</span><span class="s">"{"&#123;"}_name{38.chr + "#125;"}"</span> <span class="nt">/&gt;</span>
</pre></div>

<p>In the example above, if _name changes, the field will update, and if the field is updated, _name will be changed:</p>

<div class="highlight highlight-html"><pre>    <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"checkbox"</span> <span class="na">checked=</span><span class="s">"{"&#123;"}_checked{38.chr + "#125;"}"</span> <span class="nt">/&gt;</span>
</pre></div>

<p>If the value of a checked attribute is true, the checkbox will be shown checked. If it's checked or unchecked, the value will be updated to true or false.</p>

<p>Radio buttons bind to a checked state as well, except instead of setting the value to true or false, they set it to a supplied field value.</p>

<div class="highlight highlight-html"><pre>    <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"radio"</span> <span class="na">checked=</span><span class="s">"{"&#123;"}_radio{38.chr + "#125;"}"</span> <span class="na">value=</span><span class="s">"one"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"radio"</span> <span class="na">checked=</span><span class="s">"{"&#123;"}_radio{38.chr + "#125;"}"</span> <span class="na">value=</span><span class="s">"two"</span> <span class="nt">/&gt;</span>
</pre></div>

<p>When a radio button is checked, whatever checked is bound to is set to the field's value.  When the checked binding value is changed, any radio buttons where the binding's value matches the fields value are checked.  NOTE: This seems to be the most useful behaviour for radio buttons.</p>

<p>Select boxes can be bound to a value (while not technically a property, this is another convient behavior we add).</p>

<div class="highlight highlight-html"><pre>  <span class="nt">&lt;select</span> <span class="na">value=</span><span class="s">"{"&#123;"}_rating{38.chr + "#125;"}"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"1"</span><span class="nt">&gt;</span>*<span class="nt">&lt;/option&gt;</span>
    <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"2"</span><span class="nt">&gt;</span>**<span class="nt">&lt;/option&gt;</span>
    <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"3"</span><span class="nt">&gt;</span>***<span class="nt">&lt;/option&gt;</span>
    <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"4"</span><span class="nt">&gt;</span>****<span class="nt">&lt;/option&gt;</span>
    <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"5"</span><span class="nt">&gt;</span>*****<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;/select&gt;</span>
</pre></div>

<p>When the selected option of the select above changes, <code>_rating</code> is changed to match.  When <code>_rating</code> is changed, the selected value is changed to the first option with a matching value.  If no matching values are found, the select box is unselected.</p>

<p>If you have a controller at app/home/controller/index_controller.rb, and a view at app/home/views/index/index.html, all methods called are called on the controller.</p>

<h2>
<a id="escaping" class="anchor" href="#escaping" aria-hidden="true"><span class="octicon octicon-link"></span></a>Escaping</h2>

<p>When you need to use {"&#123;"} and {38.chr + "#125;"} outside of bindings, anything in a triple mustache will be escaped and not processed as a binding:</p>

<div class="highlight highlight-html"><pre>    {"&#123;"}{"&#123;"}{"&#123;"} bindings look like: {"&#123;"}this{38.chr + "#125;"}  {38.chr + "#125;"}{38.chr + "#125;"}{38.chr + "#125;"}
</pre></div>

<h1>
<a id="models" class="anchor" href="#models" aria-hidden="true"><span class="octicon octicon-link"></span></a>Models</h1>

<p>Volt's concept of a model is slightly different from many frameworks where a model is the name for the ORM to the database.  In Volt a model is a class where you can store data easily.  Models can be created with a "Persistor", which is responsible for storing the data in the model.  Models created without a persistor, simply store the data in the classes instance.  Lets first see how to use a model.</p>

<p>Volt comes with many built-in models; one is called <code>page</code>.  If you call <code>#page</code> on a controller, you will get access to the model.  Models provided by Volt are automatically wrapped in a ReactiveValue so update events can be tracked.</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">page</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'Ryan'</span>
    <span class="n">page</span><span class="o">.</span><span class="n">_name</span>
    <span class="c1"># =&gt; @'Ryan'</span>
</pre></div>

<p>Models act like a hash that you can access with getters and setters that start with an _ .  If an underscore method is called that hasn't yet been assigned, you will get back a "nil model".  Prefixing with an underscore makes sure we don't accidentally try to call a method that doesn't exist and get back nil model instead of raising an exception.  There is no need to define which fields a model has. Fields behave similarly to a hash, but with a different access and assignment syntax.</p>

<p>Models also let you nest data without creating the intermediate models:</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">page</span><span class="o">.</span><span class="n">_settings</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="s1">'blue'</span>
    <span class="n">page</span><span class="o">.</span><span class="n">_settings</span><span class="o">.</span><span class="n">_color</span>
    <span class="c1"># =&gt; @'blue'</span>

    <span class="n">page</span><span class="o">.</span><span class="n">_settings</span>
    <span class="c1"># =&gt; @#&lt;Model:_settings {"&#123;"}:_color=&gt;"blue"{38.chr + "#125;"}&gt;</span>
</pre></div>

<p>Nested data is automatically setup when assigned.  In this case, page._settings is a model that is part of the page model.</p>

<p>You can also append to a model if it's not defined yet.  In Volt models, plural properties are assumed to contain arrays (or more specifically, ArrayModels).</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">page</span><span class="o">.</span><span class="n">_items</span> <span class="o">&lt;&lt;</span> <span class="s1">'item 1'</span>
    <span class="n">page</span><span class="o">.</span><span class="n">_items</span>
    <span class="c1"># =&gt; @#&lt;ArrayModel ["item 1", "item 2"]&gt;</span>

    <span class="n">page</span><span class="o">.</span><span class="n">_items</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
    <span class="c1"># =&gt; @"item 1"</span>
</pre></div>

<p>ArrayModels can be appended to and accessed just like regular arrays.</p>

<h3>
<a id="nil-models" class="anchor" href="#nil-models" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nil Models</h3>

<p>As a convience, calling something like <code>page._info</code> returns what's called a NilModel (assuming it isn't already initialized).  NilModels are place holders for future possible Models.  NilModels allow us to bind deeply nested values without initializing any intermediate values.</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">page</span><span class="o">.</span><span class="n">_info</span>
    <span class="c1"># =&gt; &lt;Model:70260787225140 nil&gt;</span>

    <span class="n">page</span><span class="o">.</span><span class="n">_info</span><span class="o">.</span><span class="n">_name</span>
    <span class="c1"># =&gt; &lt;Model:70260795424200 nil&gt;</span>

    <span class="n">page</span><span class="o">.</span><span class="n">_info</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'Ryan'</span>
    <span class="c1"># =&gt; &lt;Model:70161625994820 {"&#123;"}:_info=&gt;&lt;Model:70161633901800 {"&#123;"}:_name=&gt;"Ryan"{38.chr + "#125;"}&gt;{38.chr + "#125;"}&gt;</span>
</pre></div>

<p>One gotchya with NilModels is that they are a truthy value (since only nil and false are falsy in ruby).  To make things easier, calling <code>.nil?</code> on a NilModel will return true.</p>

<p>One common place we use a truthy check is in setting up default values with || (logical or)  Volt provides a convenient method that does the same thing <code>#or</code>, but works with NilModels.</p>

<p>Instead of</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">a</span> <span class="o">||</span> <span class="n">b</span>
</pre></div>

<p>Simply use:</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">a</span><span class="o">.</span><span class="n">or</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>

<p><code>#and</code> works the same way as &amp;&amp;.  #and and #or let you easily deal with default values involving NilModels.</p>

<p>-- TODO: Document .true? / .false?</p>

<h2>
<a id="provided-collections" class="anchor" href="#provided-collections" aria-hidden="true"><span class="octicon octicon-link"></span></a>Provided Collections</h2>

<p>Above, I mentioned that Volt comes with many default collection models accessible from a controller.  Each stores in a different location.</p>

<table>
<thead>
<tr>
<th>Name</th>
<th>Storage Location</th>
</tr>
</thead>
<tbody>
<tr>
<td>page</td>
<td>page provides a temporary store that only lasts for the life of the page.</td>
</tr>
<tr>
<td>store</td>
<td>store syncs the data to the backend database and provides query methods.</td>
</tr>
<tr>
<td>local_store</td>
<td>values will be stored in the local_store</td>
</tr>
<tr>
<td>params</td>
<td>values will be stored in the params and URL.  Routes can be setup to change how params are shown in the URL.  (See routes for more info)</td>
</tr>
<tr>
<td>flash</td>
<td>any strings assigned will be shown at the top of the page and cleared as the user navigates between pages.</td>
</tr>
<tr>
<td>controller</td>
<td>a model for the current controller</td>
</tr>
</tbody>
</table>

<p><strong>more storage locations are planned</strong></p>

<h2>
<a id="arraymodel-events" class="anchor" href="#arraymodel-events" aria-hidden="true"><span class="octicon octicon-link"></span></a>ArrayModel Events</h2>

<p>Models trigger events when their data is updated.  Currently, models emit two events: added and removed.  For example:</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">model</span> <span class="o">=</span> <span class="no">Model</span><span class="o">.</span><span class="n">new</span>

    <span class="n">model</span><span class="o">.</span><span class="n">_items</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">'added'</span><span class="p">)</span> <span class="p">{"&#123;"}</span> <span class="nb">puts</span> <span class="s1">'item added'</span> <span class="p">{38.chr + "#125;"}</span>
    <span class="n">model</span><span class="o">.</span><span class="n">_items</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
    <span class="c1"># =&gt; item added</span>

    <span class="n">model</span><span class="o">.</span><span class="n">_items</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">'removed'</span><span class="p">)</span> <span class="p">{"&#123;"}</span> <span class="nb">puts</span> <span class="s1">'item removed'</span> <span class="p">{38.chr + "#125;"}</span>
    <span class="n">model</span><span class="o">.</span><span class="n">_items</span><span class="o">.</span><span class="n">delete_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># =&gt; item removed</span>
</pre></div>

<h2>
<a id="automatic-model-conversion" class="anchor" href="#automatic-model-conversion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Automatic Model Conversion</h2>

<h3>
<a id="hash---model" class="anchor" href="#hash---model" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hash -&gt; Model</h3>

<p>For convenience, when placing a hash inside of another model, it is automatically converted into a model.  Models are similar to hashes, but provide support for things like persistence and triggering reactive events.</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">user</span> <span class="o">=</span> <span class="no">Model</span><span class="o">.</span><span class="n">new</span>
    <span class="n">user</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'Ryan'</span>
    <span class="n">user</span><span class="o">.</span><span class="n">_profiles</span> <span class="o">=</span> <span class="p">{"&#123;"}</span>
      <span class="ss">_twitter</span><span class="p">:</span> <span class="s1">'http://www.twitter.com/ryanstout'</span><span class="p">,</span>
      <span class="ss">_dribbble</span><span class="p">:</span> <span class="s1">'http://dribbble.com/ryanstout'</span>
    <span class="p">{38.chr + "#125;"}</span>

    <span class="n">user</span><span class="o">.</span><span class="n">_name</span>
    <span class="c1"># =&gt; "Ryan"</span>
    <span class="n">user</span><span class="o">.</span><span class="n">_profiles</span><span class="o">.</span><span class="n">_twitter</span>
    <span class="c1"># =&gt; "http://www.twitter.com/ryanstout"</span>
    <span class="n">user</span><span class="o">.</span><span class="n">_profiles</span><span class="o">.</span><span class="n">class</span>
    <span class="c1"># =&gt; Model</span>
</pre></div>

<p>Models are accessed differently from hashes.  Instead of using <code>model[:symbol]</code> to access, you call a method <code>model.method_name</code>.  This provides a dynamic unified store where setters and getters can be added without changing any access code.</p>

<p>You can get a Ruby hash back out by calling <code>#to_h</code> on a Model.</p>

<h3>
<a id="array---arraymodel" class="anchor" href="#array---arraymodel" aria-hidden="true"><span class="octicon octicon-link"></span></a>Array -&gt; ArrayModel</h3>

<p>Arrays inside of models are automatically converted to an instance of ArrayModel.  ArrayModels behave the same as a normal Array except that they can handle things like being bound to backend data and triggering reactive events.</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">model</span> <span class="o">=</span> <span class="no">Model</span><span class="o">.</span><span class="n">new</span>
    <span class="n">model</span><span class="o">.</span><span class="n">_items</span> <span class="o">&lt;&lt;</span> <span class="p">{"&#123;"}</span><span class="ss">_name</span><span class="p">:</span> <span class="s1">'item 1'</span><span class="p">{38.chr + "#125;"}</span>
    <span class="n">model</span><span class="o">.</span><span class="n">_items</span><span class="o">.</span><span class="n">class</span>
    <span class="c1"># =&gt; ArrayModel</span>

    <span class="n">model</span><span class="o">.</span><span class="n">_items</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">class</span>
    <span class="c1"># =&gt; Model</span>
    <span class="n">model</span><span class="o">.</span><span class="n">_items</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</pre></div>

<p>To convert a Model or an ArrayModel back to a normal hash, call .to_h or .to_a respectively.  To convert them to a JavaScript Object (for passing to some JavaScript code), call <code>#to_n</code> (to native).</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">user</span> <span class="o">=</span> <span class="no">Model</span><span class="o">.</span><span class="n">new</span>
    <span class="n">user</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">'Ryan'</span>
    <span class="n">user</span><span class="o">.</span><span class="n">_profiles</span> <span class="o">=</span> <span class="p">{"&#123;"}</span>
      <span class="ss">twitter</span><span class="p">:</span> <span class="s1">'http://www.twitter.com/ryanstout'</span><span class="p">,</span>
      <span class="ss">dribbble</span><span class="p">:</span> <span class="s1">'http://dribbble.com/ryanstout'</span>
    <span class="p">{38.chr + "#125;"}</span>

    <span class="n">user</span><span class="o">.</span><span class="n">_profiles</span><span class="o">.</span><span class="n">to_h</span>
    <span class="c1"># =&gt; {"&#123;"}twitter: 'http://www.twitter.com/ryanstout', dribbble: 'http://dribbble.com/ryanstout'{38.chr + "#125;"}</span>

    <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayModel</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">]</span><span class="p">)</span>
    <span class="n">items</span>
</pre></div>

<p>You can get a normal array again by calling .to_a on an ArrayModel.</p>

<h1>
<a id="controllers" class="anchor" href="#controllers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Controllers</h1>

<p>A controller can be any class in Volt, however it is common to have that class inherit from ModelController.  A model controller lets you specify a model that the controller works off of.  This is a common pattern in Volt.  The model for a controller can be assigned by one of the following:</p>

<ol>
<li>A symbol representing the name of a provided collection model:</li>
</ol>

<div class="highlight highlight-ruby"><pre>    <span class="k">class</span> <span class="nc">TodosController</span> <span class="o">&lt;</span> <span class="no">ModelController</span>
      <span class="n">model</span> <span class="ss">:page</span>

      <span class="c1"># ...</span>
    <span class="k">end</span>
</pre></div>

<ol>
<li>Calling <code>self.model=</code> in a method:</li>
</ol>

<div class="highlight highlight-ruby"><pre>    <span class="k">class</span> <span class="nc">TodosController</span> <span class="o">&lt;</span> <span class="no">ModelController</span>
      <span class="k">def</span> <span class="nf">initialize</span>
        <span class="nb">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="ss">:page</span>
      <span class="k">end</span>
    <span class="k">end</span>
</pre></div>

<p>In methods, the <code>#model</code> method returns the current model.</p>

<p>See the <a href="#provided-collections">provided collections</a> section for a list of the available collection models.</p>

<p>You can also provide your own object to model.</p>

<p>In the example above, any methods not defined on the TodosController will fall through to the provided model.  All views in views/{"&#123;"}controller_name{38.chr + "#125;"} will have this controller as the target for any Ruby run in their bindings.  This means that calls on self (implicit or with self.) will have the model as their target (after calling through the controller).  This lets you add methods to the controller to control how the model is handled, or provide extra methods to the views.</p>

<p>Volt is more similar to an MVVM architecture than an MVC architecture.  Instead of the controllers passing data off to the views, the controllers are the context for the views.  When using a ModelController, the controller automatically forwards all methods it does not handle to the model.  This is convenient since you can set a model in the controller and then access its properties directly with methods in bindings.  This lets you do something like <code>{"&#123;"}_name{38.chr + "#125;"}</code> instead of something like <code>{"&#123;"}@model._name{38.chr + "#125;"}</code></p>

<p>Controllers in the app/home component do not need to be namespaced, all other components should namespace controllers like so:</p>

<div class="highlight highlight-ruby"><pre>    <span class="k">module</span> <span class="nn">Auth</span>
      <span class="k">class</span> <span class="nc">LoginController</span> <span class="o">&lt;</span> <span class="no">ModelController</span>
        <span class="c1"># ...</span>
      <span class="k">end</span>
    <span class="k">end</span>
</pre></div>

<p>Here "auth" would be the component name.</p>

<h2>
<a id="reactive-accessors" class="anchor" href="#reactive-accessors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reactive Accessors</h2>

<p>The default ModelController proxies any missing methods to its model.  Since models are wrapped in ReactiveValues, they return ReactiveValues by default.  Sometimes you need to store additional data reactively in the controller outside of the model.  (Though often you may want to condier doing another control/controller).  In this case, you can add a <code>reactive_accessor</code>.  These behave just like <code>attr_accessor</code> except the values assigned and returned are wrapped in a ReactiveValue.  Updates update the existing ReactiveValue.</p>

<div class="highlight highlight-ruby"><pre>  <span class="k">class</span> <span class="nc">Contacts</span> <span class="o">&lt;</span> <span class="no">ModelController</span>
    <span class="n">reactive_accessor</span> <span class="ss">:_query</span>
  <span class="k">end</span>
</pre></div>

<p>Now from the view we can bind to _query while also changing in and out the model.  You can also use <code>reactive_reader</code> and <code>reactive_writer</code></p>

<h1>
<a id="tasks" class="anchor" href="#tasks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tasks</h1>

<p>Sometimes you need to explicitly execute some code on the server. Volt solves this problem through <em>tasks</em>. You can define your own tasks by dropping a class into your component's <code>tasks</code> folder.</p>

<div class="highlight highlight-ruby"><pre>    <span class="c1"># app/main/tasks/logging_tasks.rb</span>

    <span class="k">class</span> <span class="nc">LoggingTasks</span>
        <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">channel</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="n">dispatcher</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
            <span class="vi">@channel</span> <span class="o">=</span> <span class="n">channel</span>
            <span class="vi">@dispatcher</span> <span class="o">=</span> <span class="n">dispatcher</span>
        <span class="k">end</span>

        <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="nb">puts</span> <span class="n">message</span>
        <span class="k">end</span>
    <span class="k">end</span>
</pre></div>

<p>To invoke a task from a controller use <code>tasks.call</code>.</p>

<div class="highlight highlight-ruby"><pre>    <span class="k">class</span> <span class="nc">Contacts</span> <span class="o">&lt;</span> <span class="no">ModelController</span>
        <span class="k">def</span> <span class="nf">hello</span>
            <span class="n">tasks</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'LoggingTasks'</span><span class="p">,</span> <span class="s1">'log'</span><span class="p">,</span> <span class="s1">'Hello World!'</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
</pre></div>

<p>You can also pass a block to <code>tasks.call</code> that will receive the return value of your task as soon as it's done.</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">tasks</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'MathTasks'</span><span class="p">,</span> <span class="s1">'add'</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="o">|</span>
        <span class="c1"># result should be 28</span>
        <span class="n">alert</span> <span class="n">result</span>
    <span class="k">end</span>
</pre></div>

<h1>
<a id="components" class="anchor" href="#components" aria-hidden="true"><span class="octicon octicon-link"></span></a>Components</h1>

<p>Apps are made up of Components.  Each folder under app/ is a component.  When you visit a route, it loads all of the files in the component on the front end, so new pages within the component can be rendered without a new http request.  If a URL is visited that routes to a different component, the request will be loaded as a normal page load and all of that components files will be loaded.  You can think of components as the "reload boundary" between sections of your app.</p>

<h2>
<a id="dependencies-1" class="anchor" href="#dependencies-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dependencies</h2>

<p>You can also use controls (see below) from one component in another.  To do this, you must require the component from the component you wish to use them in.  This can be done in the <code>config/dependencies.rb</code> file.  Just put</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">component</span> <span class="s1">'component_name'</span>
</pre></div>

<p>in the file.</p>

<p>Dependencies act just like require in ruby, but for whole components.</p>

<p>Sometimes you may need to include an externally hosted JS file from a component.  To do this, simply do the following in the dependencies.rb file:</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">javascript_file</span> <span class="s1">'http://code.jquery.com/jquery-2.0.3.min.js'</span>
    <span class="n">css_file</span> <span class="s1">'//netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css'</span>
</pre></div>

<p>Note above though that jquery and bootstrap are currently included by default.  Using javascript_file and css_file will be mixed in with your component assets at the correct locations according to the order they occur in the dependencies.rb files.</p>

<h2>
<a id="assets" class="anchor" href="#assets" aria-hidden="true"><span class="octicon octicon-link"></span></a>Assets</h2>

<p><strong>Note, asset management is still early, and likely will change quite a bit</strong></p>

<p>In Volt, assets such as JavaScript and CSS (or sass) are automatically included on the page for you.  Anything placed inside of a components asset/js or assets/css folder is served at /assets/{"&#123;"}js,css{38.chr + "#125;"} (via <a href="https://github.com/sstephenson/sprockets">Sprockets</a>).  Link and script tags are automatically added for each css and js file in assets/css and assets/js respectively.  Files are included in their lexical order, so you can add numbers in front if you need to change the load order.</p>

<p>Any JS/CSS from an included component or component gem will be included as well.  By default <a href="http://getbootstrap.com/">bootstrap</a> is provided by the volt-bootstrap gem.</p>

<p><strong>Note: asset bundling is on the TODO list</strong></p>

<h2>
<a id="component-generator" class="anchor" href="#component-generator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Component Generator</h2>

<p>Components can easily be shared as a gem.  Volt provides a scaffold for component gems.  In a folder (not in a volt project), simply type: volt gem {"&#123;"}component_name{38.chr + "#125;"}  This will create the files needed for the gem.  Note that all volt component gems will be prefixed with volt- so they can easily be found by others on github and rubygems.</p>

<p>While developing, you can use the component by placing the following in your Gemfile:</p>

<div class="highlight highlight-ruby"><pre><span class="n">gem</span> <span class="s1">'volt-{"&#123;"}component_name{38.chr + "#125;"}'</span><span class="p">,</span> <span class="ss">path</span><span class="p">:</span> <span class="s1">'/path/to/folder/with/component'</span>
</pre></div>

<p>Once the gem is ready, you can release it to ruby gems with:</p>

<pre><code>rake release
</code></pre>

<p>Remove the path: option in the gemfile if you wish to use the rubygems version.</p>

<h2>
<a id="provided-components" class="anchor" href="#provided-components" aria-hidden="true"><span class="octicon octicon-link"></span></a>Provided Components</h2>

<p>Volt provides a few components to make web developers' lives easier.</p>

<h3>
<a id="notices" class="anchor" href="#notices" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notices</h3>

<p>Volt automatically places <code>&lt;:volt:notices /&gt;</code> into views.  This shows notices for the following:</p>

<ol>
<li>flash messages</li>
<li>connection status (when a disconnect happens, lets the user know why and when a reconnect will be attempted)</li>
<li>page reloading notices (in development)</li>
</ol>

<h3>
<a id="flash" class="anchor" href="#flash" aria-hidden="true"><span class="octicon octicon-link"></span></a>Flash</h3>

<p>As part of the notices component explained above, you can append messages to any collection on the flash model.</p>

<p>Each collection represents a different type of "flash".  Common examples are <code>_notices, _warnings, and _errors</code>  Using different collections allows you to change how you want the flash displayed.  For example, you might want <code>_notices</code> and <code>_errors</code> to show with different colors.</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">flash</span><span class="o">.</span><span class="n">_notices</span> <span class="o">&lt;&lt;</span> <span class="s2">"message to flash"</span>
</pre></div>

<p>These messages will show for 5 seconds, then disappear (both from the screen and the collection).</p>

<h1>
<a id="controls" class="anchor" href="#controls" aria-hidden="true"><span class="octicon octicon-link"></span></a>Controls</h1>

<p>Everyone wishes that we could predict the scope and required features for each part of our application, but in the real world, things we don't expect to grow large often do and things we think will be large don't end up that way.  Controls let you quickly setup reusable code/views.  The location of the controls code can be moved as it grows without changing the way controls are invoked.</p>

<p>To render a control, simply use a tag like so:</p>

<div class="highlight highlight-html"><pre>    <span class="nt">&lt;:control-name</span> <span class="nt">/&gt;</span>
</pre></div>

<p>or</p>

<div class="highlight highlight-html"><pre>    <span class="nt">&lt;:control-name&gt;&lt;/:control-name&gt;</span>
</pre></div>

<p>To find the control's views and optional controller, Volt will search the following (in order):</p>

<table>
<thead>
<tr>
<th>Section</th>
<th>View File</th>
<th>View Folder</th>
<th>Component</th>
</tr>
</thead>
<tbody>
<tr>
<td>:{"&#123;"}name{38.chr + "#125;"}</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>:body</td>
<td>{"&#123;"}name{38.chr + "#125;"}.html</td>
<td></td>
<td></td>
</tr>
<tr>
<td>:body</td>
<td>index.html</td>
<td>{"&#123;"}name{38.chr + "#125;"}</td>
<td></td>
</tr>
<tr>
<td>:body</td>
<td>index.html</td>
<td>index</td>
<td>{"&#123;"}name{38.chr + "#125;"}</td>
</tr>
<tr>
<td>:body</td>
<td>index.html</td>
<td>index</td>
<td>gems/{"&#123;"}name{38.chr + "#125;"}</td>
</tr>
</tbody>
</table>

<p><strong>Note that anything with a view folder will also load a controller if the name/folder matches.</strong></p>

<p>Each part is explained below:</p>

<ol>
<li><p>section
Views are composed of sections.  Sections start with a <code>&lt;:SectionName&gt;</code> and are not closed.  Volt will look first for a section in the same view.</p></li>
<li><p>views
Next Volt will look for a view file with the control name.  If found, it will render the body section of that view.</p></li>
<li><p>view folder
Failing above, Volt will look for a view folder with the control name, and an index.html file within that folder.  It will render the :body section of that view.  If a controller exists for the view folder, it will make a new instance of that controller and render in that instance.</p></li>
<li><p>component
Next, all folders under app/ are checked.  The view path looked for is {"&#123;"}component{38.chr + "#125;"}/index/index.html with a section of :body.</p></li>
<li><p>gems
Lastly the app folder of all gems that start with volt are checked.  They are checked for a similar path to component.</p></li>
</ol>

<p>When you create a control, you can also specify multiple parts of the search path in the name.  The parts should be separated by a :  Example:</p>

<div class="highlight highlight-html"><pre>    <span class="nt">&lt;:blog:comments</span> <span class="nt">/&gt;</span>
</pre></div>

<p>The above would search the following:</p>

<table>
<thead>
<tr>
<th>Section</th>
<th>View File</th>
<th>View Folder</th>
<th>Component</th>
</tr>
</thead>
<tbody>
<tr>
<td>:comments</td>
<td>blog.html</td>
<td></td>
<td></td>
</tr>
<tr>
<td>:body</td>
<td>comments.html</td>
<td>blog</td>
<td></td>
</tr>
<tr>
<td>:body</td>
<td>index.html</td>
<td>comments</td>
<td>blog</td>
</tr>
<tr>
<td>:body</td>
<td>index.html</td>
<td>comments</td>
<td>gems/blog</td>
</tr>
</tbody>
</table>

<p>Once the view file for the control or template is found, it will look for a matching controller.  If the control is specified as a local template, an empty ModelController will be used.  If a controller is found and loaded, a corresponding "action" method will be called on it if its exists.  Action methods default to "index" unless the component or template path has two parts, in which case the last part is the action.</p>

<h1>
<a id="control-argumentsattributes" class="anchor" href="#control-argumentsattributes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Control Arguments/Attributes</h1>

<p>Like other html tags, controls can be passed attributes.  These are then converted into a hash and passed as the first argument to the initialize method on the controller.  The standard ModelController's initialize will then assign each key/value in the attributes hash as instance values.  This makes it easy to access attributes passed in.</p>

<div class="highlight highlight-html"><pre><span class="nt">&lt;:Body&gt;</span>

  <span class="nt">&lt;ul&gt;</span>
    {"&#123;"}#each _todos as todo{38.chr + "#125;"}
      <span class="nt">&lt;:todo</span> <span class="na">name=</span><span class="s">"{"&#123;"}todo._name{38.chr + "#125;"}"</span> <span class="nt">/&gt;</span>
    {"&#123;"}/{38.chr + "#125;"}
  <span class="nt">&lt;/ul&gt;</span>

<span class="nt">&lt;:Todo&gt;</span>
  <span class="nt">&lt;li&gt;</span>{"&#123;"}@name{38.chr + "#125;"}<span class="nt">&lt;/li&gt;</span>
</pre></div>

<h1>
<a id="routes" class="anchor" href="#routes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Routes</h1>

<p>Routes in Volt are very different from traditional backend frameworks.  Since data is synchronized using websockets, routes are mainly used to serialize the state of the application into the url in a pretty way.  When a page is first loaded, the URL is parsed with the routes and the params model's values are set from the URL.  Later if the params model is updated, the URL is updated based on the routes.</p>

<p>This means that routes in Volt have to be able to go both from URL to params and params to URL.  It should also be noted that if a link is clicked and the controller/view to render the new URL is within the current component (or an included component), the page will not be reloaded, the URL will be updated with the HTML5 history API, and the params hash will reflect the new URL.  You can use the changes in params to render different views based on the URL.</p>

<h2>
<a id="routes-file" class="anchor" href="#routes-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>Routes file</h2>

<p>Routes are specified on a per-component basis in the config/routes.rb file.  Routes simply map from URL to params.</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">get</span> <span class="s2">"/todos"</span><span class="p">,</span> <span class="p">{"&#123;"}</span><span class="ss">_view</span><span class="p">:</span> <span class="s1">'todos'</span><span class="p">{38.chr + "#125;"}</span>
</pre></div>

<p>Routes take two arguments; a path, and a params hash.  When a new URL is loaded and the path is matched on a route, the params will be set to the params provided for that route.  The specified params hash acts as a constraint.  An empty hash will match any url.  Any params that are not matched will be placed in the query parameters.</p>

<p>When the params are changed, the URL will be set to the path for the route whose params hash matches.</p>

<p>Route paths can also contain variables similar to bindings:</p>

<div class="highlight highlight-ruby"><pre>    <span class="n">get</span> <span class="s2">"/todos/{"&#123;"}_index{38.chr + "#125;"}"</span><span class="p">,</span> <span class="ss">_view</span><span class="p">:</span> <span class="s1">'todos'</span>
</pre></div>

<p>In the case above, if any URL matches /todos/*, (where * is anything but a slash), it will be the active route. <code>params._view</code> would be set to 'todos', and <code>params._index</code> would be set to the value in the path.</p>

<p>If <code>params._view</code> were 'todos' and <code>params._index</code> were not nil, the route would be matched.</p>

<p>Routes are matched top to bottom in a routes file.</p>

<h2>
<a id="debugging" class="anchor" href="#debugging" aria-hidden="true"><span class="octicon octicon-link"></span></a>Debugging</h2>

<p>An in browser irb is in the works.  We also have source maps support, but they are currently disabled by default.  To enable them run:</p>

<pre><code>MAPS=true volt s
</code></pre>

<p>This feature is disabled by default because (due to the volume of pages rendered) it slows down page rendering. We're working with the opal and sprockets teams to make it so everything is still served in one big source maps file (which would show the files as they originated on disk)</p>

<h2>
<a id="channel" class="anchor" href="#channel" aria-hidden="true"><span class="octicon octicon-link"></span></a>Channel</h2>

<p>Controllers provide a <code>#channel</code> method, that you can use to get the status of the connection to the backend.  Channel is provided in a ReactiveValue, and when the status changes, the changed events are triggered.  It provides the following:</p>

<table>
<thead>
<tr>
<th>method</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>connected?</td>
<td>true if it is connected to the backend</td>
</tr>
<tr>
<td>status</td>
<td>possible values: :opening, :open, :closed, :reconnecting</td>
</tr>
<tr>
<td>error</td>
<td>the error message for the last failed connection</td>
</tr>
<tr>
<td>retry_count</td>
<td>the number of reconnection attempts that have been made without a successful connection</td>
</tr>
<tr>
<td>reconnect_interval</td>
<td>the time until the next reconnection attempt (in seconds)</td>
</tr>
</tbody>
</table>

<h1>
<a id="testing" class="anchor" href="#testing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testing</h1>

<p>** Testing is being reworked at the moment.
Volt provides rspec and capybara out of the box.  You can test directly against your models, controllers, etc... or you can do full integration tests via <a href="https://github.com/jnicklas/capybara">Capybara</a>.</p>

<p>To run Capybara tests, you need to specify a driver.  The following drivers are currently supported:</p>

<ol>
<li>Phantom (via poltergeist)</li>
</ol>

<p><code>BROWSER=phantom bundle exec rspec</code></p>

<ol>
<li>Firefox</li>
</ol>

<p><code>BROWSER=firefox bundle exec rspec</code></p>

<ol>
<li>IE - coming soon</li>
</ol>

<p>Chrome is not supported due to <a href="https://code.google.com/p/chromedriver/issues/detail?id=887#makechanges">this issue</a> with ChromeDriver.  Feel free to go <a href="https://code.google.com/p/chromedriver/issues/detail?id=887#makechanges">here</a> and pester the chromedriver team to fix it.</p>

<h1>
<a id="volt-helpers" class="anchor" href="#volt-helpers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Volt Helpers</h1>

<h2>
<a id="logging" class="anchor" href="#logging" aria-hidden="true"><span class="octicon octicon-link"></span></a>Logging</h2>

<p>Volt provides a helper for logging.  Calling <code>Volt.logger</code> returns an instance of the ruby logger.  See <a href="http://www.ruby-doc.org/stdlib-2.1.3/libdoc/logger/rdoc/Logger.html">here</a> for more.</p>

<div class="highlight highlight-ruby"><pre><span class="no">Volt</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"Some info..."</span><span class="p">)</span>
</pre></div>

<p>You can change the logger with:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Volt</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="no">Logger</span><span class="o">.</span><span class="n">new</span>
</pre></div>

<h2>
<a id="accessing-dom-section-in-a-controller" class="anchor" href="#accessing-dom-section-in-a-controller" aria-hidden="true"><span class="octicon octicon-link"></span></a>Accessing DOM section in a controller</h2>

<p>TODO</p>

<h1>
<a id="data-store" class="anchor" href="#data-store" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data Store</h1>

<p>Volt provides a data store collection on the front-end and the back-end.  In store, all plural names are assumed to be collections (like an array), and all singular are assumed to be a model (like a hash).</p>

<div class="highlight highlight-ruby"><pre><span class="n">store</span><span class="o">.</span><span class="n">_things</span>
</pre></div>

<p><strong>Work in progress</strong></p>

<table>
<thead>
<tr>
<th>state</th>
<th>events bound</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>not_loaded</td>
<td>no</td>
<td>no events and no one has accessed the data in the model</td>
</tr>
<tr>
<td>loading</td>
<td>maybe</td>
<td>someone either accessed the data or bound an event</td>
</tr>
<tr>
<td>loaded</td>
<td>yes</td>
<td>data is loaded and there is an event bound</td>
</tr>
<tr>
<td>dirty</td>
<td>no</td>
<td>data was either accessed without binding an event, or an event was bound, but later unbound.</td>
</tr>
</tbody>
</table>

<h1>
<a id="contributing" class="anchor" href="#contributing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contributing</h1>

<p>You want to contribute?  Great!  Thanks for being awesome!  At the moment, we have a big internal todo list, hop on <a href="https://gitter.im/voltrb/volt">https://gitter.im/voltrb/volt</a> so we don't duplicate work.  Pull requests are always welcome, but asking about helping on gitter should save some duplication.</p>

<p><a href="https://pledgie.com/campaigns/26731"><img src="https://pledgie.com/campaigns/26731.png?skin_name=chrome" alt="Pledgie" style="max-width:100%;"></a></p>
      </div>

</div>